/*
________________________________________________________________________________
[]                                                                            []
[] This is a part of the PROJECT: 'ObjBase'												[]
[] Copyright (C) 1999 W:Brain                                                 []
[] All rights reserved.                                                       []
[] __________________________________________________________________________ []
[]                                                                            []
[] Name:            Object.h																	[]
[] Date:            14.04.99                                                  []
[] Author:          Roman V. Koshelev														[]
[] Description:     Базовый класс для всех контроллеров объектов базы данных	[]
[]____________________________________________________________________________[]
*/
#ifndef Object_h
#define Object_h

#include "SmartField.h"

/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` OC_Object
[]                                                                            []
[]____________________________________________________________________________[]
*/
template <class OC> class OC_Object
{
// Это класс объектов-контроллеров.
// Использовать контроллеры (не "Мастер") можно двумя способами --
// прямым и индексным. В первом случае контроллер нужно
// проинициализировать с помощью уникального идентификатора.
// Во втором -- установить контроллер на объект, пользуясь 
// функциями работы с индексами -- Find, Next, Prev, ....
// Внимание: Класcы OC_xxx автоматически создаются компилятором базы данных.
   void About_class_OC_Object (){};

// Идентификатор класса объекта
   public:    identifier   classID;

// Внутренний идентификатор для доступа к данным через OBD
   protected: OBD_pointer  coPtr;

// Информация об установленном индексе
   protected: CIndexInfo   curIndexInfo;

// Очистить контроллер и уменьшить счётчик объекта-данных
   protected: void Release (OBD_pointer _coPtr=NULL)
	{
      if(_coPtr!=NULL)
		{
         OBD_ReleaseObject (classID, _coPtr);
		}
      else if(coPtr!=NULL) 
		{
			OBD_ReleaseObject (classID, coPtr);
			coPtr = NULL;
      }
   }

// Закрыть контроллер = Release
   public: void Close ()
	{
		Release();
   }


//RVK:>>>
/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ОБЩИЕ МЕТОДЫ																					[]
[]                                                                            []
[]____________________________________________________________________________[]
*/

// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
   public: void DebugPrint(string& dbg) const {OBD_DebugPrint(classID, dbg, coPtr);};
// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
   public: void DebugPrint() const {string dbg; OBD_DebugPrint(classID, dbg, coPtr); dbg.Print ();};

// Проверка возможности использования контроллера
   public: bool IsValid () const {return OBD_IsObjectValid (classID, coPtr);};

// Проверка существования объекта данного класса с указанным идентификатором
   public: bool Exist (identifier objID) const {return OBD_Exist (classID, objID);};

// Проверка возможности использования контроллера
   public: operator bool () const {return IsValid ();};

// Сохранение всей базы на диск (объекты и индексы)
// Для своего выполнения может потребовать времени ~266 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
	public: void SaveAllBase ()  {OBD_SaveAllData ();}

// Сохранение всех изменённых объектов и индексов на диск. Операция полезна 
// для уплотнения памяти. Не требует специальных защитных мер -- можно вызывать в любой момент.
// Для своего выполнения может потребовать времени ~498 (266+232) секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
   public: void ReloadAllBase () const {OBD_ReloadAllBase();};

// Запись изменений в файловой системе.
// Для своего выполнения может потребовать времени ~7.7 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
   public: void FlushFileSystem () const {theFileDriver.flush ();};	


// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (const OC& to) {return coPtr==to.coPtr;};
// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (identifier objID)  {return objID == (coPtr? GetObjectID(): UNKNOWN);};

// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (const OC& to) {return coPtr!=to.coPtr;};
// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (identifier objID)  {return objID != (coPtr? GetObjectID(): UNKNOWN);};

// Получить идентификатор контролируемого объекта
   public: operator identifier () const        {return coPtr? GetObjectID(): UNKNOWN;};

// Загрузка объекта по идентификатору
   public: void Open (identifier objID) 
	{
		if (coPtr!=NULL && (objID==GetObjectID())) 
			return; 
		Release();
		if (objID==NA) 
		{
			SERVER_DEBUG_ERROR_1 ("OC_Object::Open (NA) -- попытка загрузить неизвестный объект класса '%s'", GetClassName ());
			return; 
		}
		coPtr=OBD_GetObject(classID,objID);
	}






// Принудительное сохранение объекта на диск
   public: void Save () {if (coPtr) OBD_SaveObject(classID,coPtr);}


// Создать новый объекта и добавить его в базу.
// Возвращает идентификатор нового объекта и устанавливает
// на него данный контроллер. 
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА!
   public: identifier New () {Release(); coPtr=OBD_CreateObject(classID); return GetObjectID();};

// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete () {OBD_DeleteObject(classID,coPtr); if (!IsValid()) Release();};
// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete (identifier objID) { OBD_DeleteObject(classID,objID); if (!IsValid()) Release();};


// Получить идентификатор контролируемого объекта.
   public: identifier GetObjectID () const {return coPtr? OBD_GetObjectID(classID, coPtr): UNKNOWN;};

// Получить идентификатор класса контролируемого объекта.
   public: identifier GetClassID () const {return coPtr? OBD_GetClassID(classID, coPtr): classID;} 
// Получить имя класса контролируемого объекта.
   public: const char * GetClassName () const {return className[GetClassID()];}




//RVK:>>>
/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ ОБЪЕКТОВ														[]
[]                                                                            []
[]____________________________________________________________________________[]
*/

// Получить список идентификаторов всех объектов данного класса.
// Если уазан ключ, функция заполняет список идентификаторами 
// всех объектов, удовлетворяющие ключу. 
// Первый агрумент -- CPtr<identifier> id_list;
// Идентификаторы будут отсортированы в соответствии с текущим индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: void GetClassIdList (identifier_arr& id_list, key_arr* ka=NULL) {OBD_GetClassIdList(id_list, classID, ka, curIndexInfo);};

// Удалить все объекты данного класса из базы.
// Для своего выполнения может потребовать времени ~41 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void DeleteClassObjects () {key_arr ka; OBD_DeleteObject(classID,ka,curIndexInfo); if (!IsValid()) Release();};

// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete (key_arr& ka)						{ OBD_DeleteObject(classID,ka,curIndexInfo); if (!IsValid()) Release();};

// Принудительное сохранение текущего индекса на диск
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: void SaveCurIndex () {OBD_SaveIndexToFile(classID,curIndexInfo);}
// Получить идентификатор первого объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: identifier First() const {return OBD_FirstIDInIndex (classID, curIndexInfo);};

// Получить идентификатор последнего объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: identifier Last() const {return OBD_LastIDInIndex (classID, curIndexInfo);};

// Значение ключа по текущему индексу меньше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator< (key_arr& ka)  {return Compare (ka)< 0;};

// Значение ключа по текущему индексу меньше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator<=(key_arr& ka)  {return Compare (ka)<=0;};

// Значение ключа по текущему индексу больше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator> (key_arr& ka)  {return Compare (ka)> 0;};

// Значение ключа по текущему индексу больше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator>=(key_arr& ka)  {return Compare (ka)>=0;};

// Сравнение значение ключа по текущему индексу с ключом-аргументом
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: int  Compare   (key_arr& ka)  {return coPtr? OBD_CompareToKeyVarArr (classID,curIndexInfo,coPtr,ka): -1;};

// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (key_arr& ka)  {return Compare (ka)==0;};

// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (key_arr& ka)  {return Compare (ka)!=0;};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Поиск по индексу
//
//RVK:>>>

// Найти объект в текущем индексе по набору ключей 'keyarr'.
// При нестрогом поиске находится объект с ключём меньшим или равным ключу поиска:
//      key_arr ka; // Полный ключ = [Имя, Фамилия, Возраст]
//      ka += "Вася"; ka += "Пупкин"; ka += 28;
//      Men.Find (ka); // Находим Васю Пупкина 28-и лет и никого более.
//      Men.Find (ka, true); // Находим Васю Пупкина 28-и лет или Васю Пупкина 27-и лет 
//      // или Васю Аббакумова 92 лет или Абрамчика Цукермана 13 лет.
// Если набор ключей 'keyarr' неполный, игнорируются поля, не указанными в 'keyarr':
//      ka += "Вася"; ka += "Пупкин";
//      Men.Find (ka); // Находим первого попавшегося Васю Пупкина, причём
//      // его возраст будет минимальным среди всех имеющихся Васек Пупкиных.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool Find (key_arr& ka, bool bInexact=false) {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexFindObject  (classID,curIndexInfo,ka,bInexact); if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти на следующий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на следующий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на следующий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNext (key_arr* pka=NULL, bool bUnique=false) 
	{
		OBD_pointer _coPtr=coPtr; 
		coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,pka,bUnique);   
		if(_coPtr)
			Release (_coPtr); 
		return coPtr!=NULL;
	}

// Перейти на предыдущий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на предыдущий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на предыдущий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrev (key_arr* pka=NULL, bool bUnique=false) {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,pka,bUnique);   if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти по текущему индексу на следующий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNextSame (key_arr* pka=NULL, bool bUnique=false) {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,pka,bUnique,true);   if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти по текущему индексу на предыдущий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrevSame (key_arr* pka=NULL, bool bUnique=false) {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,pka,bUnique,true);   if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти на первый объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoFirst() {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexFirstObject (classID,curIndexInfo,coPtr);       if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти на последний объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoLast () {OBD_pointer _coPtr=coPtr; coPtr=OBD_IndexLastObject  (classID,curIndexInfo,coPtr);       if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator++() {return GoNext();}
// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator++(int) {return GoNext();}

// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator--() {return GoPrev();}
// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator--(int) {return GoPrev();}


// Перейти по текущему индексу на следующий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNextUnique () {OBD_pointer _coPtr=coPtr; key_arr ka; coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,&ka,true);   if(_coPtr)Release(_coPtr); return coPtr!=NULL;}

// Перейти по текущему индексу на предыдущий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrevUniqeu () {OBD_pointer _coPtr=coPtr; key_arr ka; coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,&ka,true);   if(_coPtr)Release(_coPtr); return coPtr!=NULL;}




// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Подсчёты по индексу
//
//RVK:>>> 



// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum (key_arr& ka1, key_arr& ka2) const {
				  return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,true);}
// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum (key_arr& ka) const {
				  key_arr ka2;
				  ka2.Init();
				  return OBD_GetIndexNumForKey(classID,curIndexInfo,ka,ka2,true);}
// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum () const {
				  key_arr ka1; 
				  key_arr ka2; 
				  return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,true);}

// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum (key_arr& ka1, key_arr& ka2) const {
				  return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,false);}
// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum (key_arr& ka) const {
				  key_arr ka2;
				  ka2.Init();
				  return OBD_GetIndexNumForKey(classID,curIndexInfo,ka,ka2,false);}
// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum () const {return OBD_IndexTotalNum (classID);}

// Получить общее число объектов данного класса
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetTotalNum() const {return OBD_IndexTotalNum (classID);};
};
//____________________________________________________________________________[]




#endif
/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[] END OF FILE                                                                []
[]                                                                            []
[]____________________________________________________________________________[]
*/