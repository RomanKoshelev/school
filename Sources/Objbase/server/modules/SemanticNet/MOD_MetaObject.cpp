/*______________________________________________________________________________
[]                                                                            []
[] This is a part of the project 'IT'                                         []
[] Copyright (C) 2000 by the author(s) -- see below.									[]
[] All rights reserved.                                                       []
[] __________________________________________________________________________ []
[]                                                                            []
[] Name:          MOD_MetaObject.cpp														[]
[] Date:          03.10.2000																	[]
[] Author:        Roman V. Koshelev															[]
[] Description:   Работа с объектами класса MetaObject								[]
[]						Интерфейсные функции.													[]
[]____________________________________________________________________________[]
*/
#include "MOD_MetaObject.inc.h"				 






//______________________________________________________________________________
//                                                                            []
//                                                                            []
//` СОЗДАНИЕ НОВОГО ОБЪЕКТА КЛАССА MetaObject											[]
//                                                                            []
//____________________________________________________________________________[]
//
//
//
ERR_RESULT MOD_MetaObject_New (MOD_MetaObject_Args& arg)
{
	DEBUG_STACK_NAME (MOD_MetaObject_New);
/*............................................................................[]
		<Login						Логин пользователя, запрашивающего операцию. Пользователь должен иметь права создания метаобъектов [C] в указанных зонах.
		<Password					Пароль пользователя, запрашивающего операцию.

		<Type							Тип метаобъекта.
		<Name							Имя метаобъекта.
		<SysName						Системное имя метаобъекта, строится как переменная С++. Если не пусто, то имя должно быть уникально внутри типа.
		<FeodIDs						Зоны доступа, к которым будет принадлежать метаобъект {Concept.Feod.Semantic}. Должна быть указана хотя-бы одна зона.

		>objID						Идентификатор созданного объекта.
		>ProxyID						Для семантической сети -- идентификатор соответствующего прокси-объекта.

		>ExitCode					Код возврата.
		>ExitCodeComment			Текстовый комментарий к коду возврата.
*///..........................................................................[]


//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка доступа																				[]                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Проверяем логин и пароль
	identifier loginID=NA;
	ERR_RESULT res = USER_CHECK_LOGIN_PASSWORD (arg.Login, arg.Password, loginID);
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Некорректный пароль или логин");
	}
// Проверяем право доступа -- пользователь должен иметь право создавать объекты в указанных феодах
	int f;
	for (f=0; f<arg.FeodIDs.Size(); f++)
	{
		res = USER_CHECK_ACCESS (loginID, arg.FeodIDs[f], "C");
		if (res!=ERR_OK)
		{
			string feodName;
			GetFeodName (arg.FeodIDs[f], feodName);
			ERR_RETURN_COMMENT_2 (res, "Пользователь не имеет права создавать объекты в зоне '%s'[%u]", feodName.c_str(), arg.FeodIDs[f]);
		}
	}
//----------------------------------------------------------------------------[] 



//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка аргументов	                                                      []                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Имя объекта не должно быть пустым
	if (arg.Name.IsEmpty())
	{
		ERR_RETURN_COMMENT (ERR_BadName, "Имя создаваемого объекта не должно быть пустым");
	}
// Системное имя должно быть корректным
	if (!arg.SysName.IsEmpty() && !arg.SysName.CheckSysName())
	{
		SERVER_DEBUG_ERROR_1 ("Некорректное системное имя %s", arg.SysName.c_str());
	}
// Если не пусто, то системное имя должно быть уникально внутри типа.
	OC_MetaObject oc_meta;
	key_arr ka; ka+=arg.Type; ka+=arg.SysName;
	oc_meta.SetIndex_Type_SysName ();
	if (!arg.SysName.IsEmpty() && oc_meta.Find (ka))
	{
		ERR_RETURN_COMMENT_2 (ERR_NameAlreadyExists, "Уже есть объект с системным именем '%s' типа '%s' -- Системное имя объекта внутри типа должно быть уникальным или пустым", arg.SysName.c_str(), arg.Type.c_str());
	}
// Объект должен иметь зону доступа
	if (arg.FeodIDs.Size()==0)
	{
		ERR_RETURN_COMMENT (ERR_BadArgument, "Не указана зона доступа создаваемого объекта");
	}
// Преобразовываем зоны доступа в guid'ы
	guid_arr FeodGUIDs;
	GetFeodGUIDs (arg.FeodIDs, FeodGUIDs);
//----------------------------------------------------------------------------[] 



//----------------------------------------------------------------------------[] 
//                                                                            []
// Выполнение запроса																			[]
//                                                                            []
//----------------------------------------------------------------------------[] 
// Создаём объект
	oc_meta.New					();
	identifier metaID			= oc_meta.GetObjectID ();
// Создаём прокси-объект для семантической сети
	CHECK_PROXY_OBJECT_OF	(oc_meta);

// Прописываем значения в поля объекта
	oc_meta.m_Type				=	arg.Type;
	oc_meta.m_Name				=	arg.Name;
	oc_meta.m_SysName			=	arg.SysName;

// Запоминаем идентификатор объекта и его семантического заместителя 
	arg.objID					=	metaID;
	arg.ProxyID					=	guid(oc_meta.m_ProxyObject).id;
//----------------------------------------------------------------------------[] 


	ERR_RETURN (ERR_OK);
}
//____________________________________________________________________________[]













//______________________________________________________________________________
//                                                                            []
//                                                                            []
//` ПЕРЕЧИСЛЕНИЕ ДОСТУПНЫХ ОБЪЕКТОВ КЛАССА MetaObject									[]
//                                                                            []
//____________________________________________________________________________[]
//
//
//
ERR_RESULT MOD_MetaObject_Enumerate (MOD_MetaObject_Args& arg)
{
	DEBUG_STACK_NAME (MOD_MetaObject_Enumerate);
/*............................................................................[]
		<Login						Логин пользователя, запрашивающего операцию. Пользователь должен иметь права получения списка [L].
		<Password					Пароль пользователя, запрашивающего операцию.

		<TypePrefix					Перечислятся те объекты, тип которых начинается с указанного префикса.
		<objFirstNo					Номер объекта, начиная с которого выводятся объекты функцией Enumerate(). По умолчанию равен 0. 
		<objLastNo					Номер объекта, до которого включительно выводятся объекты функцией Enumerate(). По умолчанию равен последнему порядковому номеру.

		>objIDs						Массив идентификаторов перечисленных объектов.
		>objTypes					Массив типов метаобъектов.
		>objNames					Массив названий перечисленных объектов.
		>objSysNames				Массив системных имён метаобъектов.
		>objProxyIDs				Для семантической сети -- массив идентификаторов соответствующих прокси-объектов.

		>TotalStoredNum			Сколько всего объектов может быть перечислено в данных условиях.
		>MaxNumInQuery				Максимально допустимое число запрашиваемых за один раз объектов.

		>ExitCode					Код возврата.
		>ExitCodeComment			Текстовый комментарий к коду возврата.
*///..........................................................................[]




//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка доступа																				[]                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Проверяем логин и пароль
	identifier loginID=NA;
	ERR_RESULT res = USER_CHECK_LOGIN_PASSWORD (arg.Login, arg.Password, loginID);
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Некорректный пароль или логин");
	}
//----------------------------------------------------------------------------[] 



//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка аргументов	                                                      []                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Чтобы не запросили слишком много объектов
	arg.objFirstNo = max (arg.objFirstNo, 0);
	if (arg.objLastNo==INT_MAX) arg.objLastNo=arg.objFirstNo+MAX_METAOBJECT_ENUMERATE_NUM;
	if ((arg.objLastNo - arg.objFirstNo) > MAX_METAOBJECT_ENUMERATE_NUM)
	{
		ERR_RETURN_COMMENT_2 (ERR_TooManyEnumerate, "Запрошено %d объектов класса MetaObject, а максимально можно запросить %d", (arg.objLastNo - arg.objFirstNo), MAX_METAOBJECT_ENUMERATE_NUM);
	}
//----------------------------------------------------------------------------[] 




//----------------------------------------------------------------------------[] 
//                                                                            []
// Выполнение запроса																			[]
//                                                                            []
//----------------------------------------------------------------------------[] 
// Получаем список всех объектов с указанным префиксом
	int							N,i,j;
	OC_MetaObject				oc_meta;
	identifier_arr				ALL_METAOBJECT_IDs;
	key_arr ka;
	ka+=arg.TypePrefix;

	oc_meta.SetIndex_Type_Name ();

	//----------------------------------------------------------------------------[] 
	if (!oc_meta.Find (ka, true)) oc_meta.GoFirst();
	for (; oc_meta.IsValid (); oc_meta++)
	{
		if (oc_meta >= ka)
		{
			if (string(oc_meta.m_Type).Find ((const char*)arg.TypePrefix)!=0)
			{
				break;
			}
			ALL_METAOBJECT_IDs += oc_meta.GetObjectID ();
		}
	}
	//----------------------------------------------------------------------------[] 


// Вычеркиваем те объекты, к которым нет доступа
	for (i=0; i<ALL_METAOBJECT_IDs.Size(); i++)
	{
		if (USER_CHECK_ACCESS_TO_METAOBJECT (loginID, ALL_METAOBJECT_IDs[i], "L")!=ERR_OK)
		{
			ALL_METAOBJECT_IDs [i] = NA;
		}
	}

// Проходимся по всем удовлетворяющим объектам и заполняем выходные аргументы
	for (N=0, j=0, i=0; i<ALL_METAOBJECT_IDs.Size(); i++) if (ALL_METAOBJECT_IDs[i]!=NA)
	{
		if (j<arg.objFirstNo || j>arg.objLastNo) {j++; continue;} else j++; N++;

		oc_meta.Open (ALL_METAOBJECT_IDs[i]);
		arg.objIDs			+= ALL_METAOBJECT_IDs[i];
		arg.objTypes		+=	oc_meta.m_Type;
		arg.objNames		+=	oc_meta.m_Name;
		arg.objSysNames	+=	oc_meta.m_SysName;
		arg.objProxyIDs	+= guid (oc_meta.m_ProxyObject).id;
	}

// Общее число объектов, которых можно перечислить
	arg.TotalStoredNum	=	N;
//----------------------------------------------------------------------------[] 


	ERR_RETURN (ERR_OK);
}
//____________________________________________________________________________[]













//______________________________________________________________________________
//                                                                            []
//                                                                            []
//` ПОЛУЧЕНИЕ ДАННЫХ ОБЪЕКТА КЛАССА MetaObject											[]
//                                                                            []
//____________________________________________________________________________[]
//
//
//
ERR_RESULT MOD_MetaObject_GetData (MOD_MetaObject_Args& arg)
{
	DEBUG_STACK_NAME (MOD_MetaObject_GetData);
/*............................................................................[]
		<Login						Логин пользователя, запрашивающего операцию. Пользователь должен иметь право чтения [R].
		<Password					Пароль пользователя, запрашивающего операцию.

		<objID						Идентификатор запрашиваемого объекта.

		>ProxyID						Для семантической сети -- идентификатор соответствующего прокси-объекта.
		>Type							Тип объекта.
		>Name							Имя объекта.
		>SysName						Системное название объекта.
		>FeodIDs						Зоны доступа, к которым принадлежит метаобъект {Concept.Feod.Semantic}.

		>ReadOnly					Имеет ли пользователь право редактировать объект

		>ExitCode					Код возврата.
		>ExitCodeComment			Текстовый комментарий к коду возврата.
*///..........................................................................[]




//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка доступа																				[]                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Запрашиваемый объект должен существовать
	if (!OC_Exist (OBJ_CLASS_ID_MetaObject, arg.objID))
	{
		ERR_RETURN_COMMENT_1 (ERR_BadID, "Запрашиваемый объект MetaObject[%u] не существует", arg.objID);
	}
	OC_MetaObject oc_meta (arg.objID);
// Проверяем логин и пароль
	identifier loginID=NA;
	ERR_RESULT res = USER_CHECK_LOGIN_PASSWORD (arg.Login, arg.Password, loginID);
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Некорректный пароль или логин");
	}
// Проверяем право доступа
	res = USER_CHECK_ACCESS_TO_METAOBJECT (loginID, arg.objID, "R");
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Нет доступа для выполнения операции");
	}
//----------------------------------------------------------------------------[] 





//----------------------------------------------------------------------------[] 
//                                                                            []
// Выполнение запроса																			[]
//                                                                            []
//----------------------------------------------------------------------------[] 
// Заполняем аргументы полями объекта
	arg.ProxyID		=	guid(oc_meta.m_ProxyObject).id;
	arg.Type			=	oc_meta.m_Type;
	arg.Name			=	oc_meta.m_Name;
	arg.SysName		=	oc_meta.m_SysName;
	arg.ReadOnly	=	(USER_CHECK_ACCESS_TO_METAOBJECT (loginID, arg.objID, "W")!=ERR_OK);
	for (int i=0; i<oc_meta.m_FeodGUID.Size(); i++) arg.FeodIDs += guid(oc_meta.m_FeodGUID[i]).id;
//----------------------------------------------------------------------------[] 


	ERR_RETURN (ERR_OK);
}
//____________________________________________________________________________[]













//______________________________________________________________________________
//                                                                            []
//                                                                            []
//` ИЗМЕНЕНИЕ ДАННЫХ ОБЪЕКТА КЛАССА MetaObject											[]
//                                                                            []
//____________________________________________________________________________[]
//
//
//
ERR_RESULT MOD_MetaObject_PutData (MOD_MetaObject_Args& arg)
{
	DEBUG_STACK_NAME (MOD_MetaObject_PutData);
/*............................................................................[]
		<Login						Логин пользователя, запрашивающего операцию. Пользователь должен иметь право записи [W].
		<Password					Пароль пользователя, запрашивающего операцию.

		<objID						Идентификатор изменяемого объекта.
		<Type							Тип метаобъекта.
		<Name							Название метаобъекта.
		<SysName						Системное название метаобъекта, строится как переменная С++. Если не пусто, то имя должно быть уникально внутри типа.
		<FeodIDs						Зоны доступа, к которым принадлежит метаобъект {Concept.Feod.Semantic}.

		>ExitCode					Код возврата.
		>ExitCodeComment			Текстовый комментарий к коду возврата.
*///..........................................................................[]




//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка доступа																				[]                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Запрашиваемый объект должен существовать
	if (!OC_Exist (OBJ_CLASS_ID_MetaObject, arg.objID))
	{
		ERR_RETURN_COMMENT_1 (ERR_BadID, "Запрашиваемый объект MetaObject[%u] не существует", arg.objID);
	}
	OC_MetaObject oc_meta (arg.objID);
// Проверяем логин и пароль
	identifier loginID=NA;
	ERR_RESULT res = USER_CHECK_LOGIN_PASSWORD (arg.Login, arg.Password, loginID);
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Некорректный пароль или логин");
	}
	OC_User oc_login (loginID);
// Проверяем право доступа
	res = USER_CHECK_ACCESS_TO_METAOBJECT (loginID, arg.objID, "W");
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Нет доступа для выполнения операции");
	}
//	Проверяем уровень доступа
	if (oc_meta.m_AccessLevelThreshold <= oc_login.m_AccessLevel)
	{
		ERR_RETURN_COMMENT_2 (ERR_InsufficientAccessLevel, "Недостаточный уровень доступа (%d) для изменения метаобъекта (%d)", int(oc_login.m_AccessLevel), int(oc_meta.m_AccessLevelThreshold));
	}
//----------------------------------------------------------------------------[] 




//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка аргументов	                                                      []                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Имя объекта не должно быть пустым
	if (arg.Name.IsEmpty())
	{
		ERR_RETURN_COMMENT (ERR_BadName, "Имя метаобъекта не должно быть пустым");
	}
// Системное имя должно быть корректным
	if (!arg.SysName.IsEmpty() && !arg.SysName.CheckSysName())
	{
		SERVER_DEBUG_ERROR_1 ("Некорректное системное имя '%s'", arg.SysName.c_str());
	}
// Если не пусто, то системное имя должно быть уникально внутри типа.
	key_arr ka; ka+=arg.Type; ka+=arg.SysName;
	oc_meta.SetIndex_Type_SysName ();
	if (!arg.SysName.IsEmpty() && oc_meta.Find (ka) && oc_meta.GetObjectID()!=arg.objID)
	{
		ERR_RETURN_COMMENT_2 (ERR_NameAlreadyExists, "Уже есть другой объект с системным именем '%s' типа '%s' -- Системное имя объекта внутри типа должно быть уникальным или пустым", arg.SysName.c_str(), arg.Type.c_str());
	}
// Пользователь не может убрать зоны доступа, к которым не имеет атрибута доступа [D]
	int i,j;
	for (i=0; i<oc_meta.m_FeodGUID.Size(); i++)
	{
		guid gi = oc_meta.m_FeodGUID[i];
		if (arg.FeodIDs.Find (gi.id)==-1)
		{
			if (USER_CHECK_ACCESS (loginID, gi.id, "D")!=ERR_OK)
			{
				string feodName;
				GetFeodName(gi.id, feodName);
				ERR_RETURN_COMMENT_2 (ERR_AccessDeny, "Пользователь не имеет права удалять объект из зоны доступа '%s'[%u]", feodName.c_str(), arg.FeodIDs[i]);
			}
		}
	}
// Пользователь не может назначить зоны доступа, к которым не имеет атрибута доступа [C]
	for (i=0; i<arg.FeodIDs.Size(); i++)
	{
		bool bFoundInRel = false;
	//	Ищем указанную зону в отношении
		for (j=0; j<oc_meta.m_FeodGUID.Size(); j++)
		{
			if (guid(oc_meta.m_FeodGUID[j]).id == arg.FeodIDs[i])
			{
				bFoundInRel = true;
				break;
			}
		}
	//	Если зона не найдена в отношении -- значии её добавили, проверяем право
		if (!bFoundInRel && USER_CHECK_ACCESS (loginID, arg.FeodIDs[i], "C")!=ERR_OK)
		{
			string feodName;
			GetFeodName (arg.FeodIDs[i], feodName);
			ERR_RETURN_COMMENT_2 (ERR_AccessDeny, "Пользователь не имеет права вносить объект в зону доступа '%s'[%u]", feodName.c_str(), arg.FeodIDs[i]);
		}
	}
// Преобразовываем зоны доступа в guid'ы
	guid_arr FeodGUIDs;
	GetFeodGUIDs (arg.FeodIDs, FeodGUIDs);
//----------------------------------------------------------------------------[] 





//----------------------------------------------------------------------------[] 
//                                                                            []
// Выполнение запроса																			[]
//                                                                            []
//----------------------------------------------------------------------------[] 
// Изменяем поля объекта
	oc_meta.m_Type			=	arg.Type;
	oc_meta.m_Name			=	arg.Name;
	oc_meta.m_SysName		=	arg.SysName;
	oc_meta.m_FeodGUID	=	FeodGUIDs;
//----------------------------------------------------------------------------[] 


	ERR_RETURN (ERR_OK);
}
//____________________________________________________________________________[]













//______________________________________________________________________________
//                                                                            []
//                                                                            []
//` УДАЛЕНИЕ ОБЪЕКТА КЛАССА MetaObject														[]
//                                                                            []
//____________________________________________________________________________[]
//
//
//
ERR_RESULT MOD_MetaObject_Delete (MOD_MetaObject_Args& arg)
{
	DEBUG_STACK_NAME (MOD_MetaObject_Delete);
/*............................................................................[]
		<Login						Логин пользователя, запрашивающего операцию. Пользователь должен иметь право удаления [D].
		<Password					Пароль пользователя, запрашивающего операцию.

		<objID						Идентификатор удаляемого объекта.

		>ExitCode					Код возврата.
		>ExitCodeComment			Текстовый комментарий к коду возврата.
*///..........................................................................[]




//----------------------------------------------------------------------------[] 
//                                                                            []
// Проверка доступа																				[]                    
//                                                                            []
//----------------------------------------------------------------------------[] 
// Запрашиваемый объект должен существовать
	if (!OC_Exist (OBJ_CLASS_ID_MetaObject, arg.objID))
	{
		ERR_RETURN_COMMENT_1 (ERR_BadID, "Запрашиваемый объект MetaObject[%u] не существует", arg.objID);
	}
	OC_MetaObject oc_meta (arg.objID);
// Проверяем логин и пароль
	identifier loginID=NA;
	ERR_RESULT res = USER_CHECK_LOGIN_PASSWORD (arg.Login, arg.Password, loginID);
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Некорректный пароль или логин");
	}
// Проверяем право доступа
	res = USER_CHECK_ACCESS_TO_METAOBJECT (loginID, arg.objID, "D");
	if (res!=ERR_OK)
	{
		ERR_RETURN_COMMENT (res, "Нет доступа для выполнения операции");
	}
//----------------------------------------------------------------------------[] 





//----------------------------------------------------------------------------[] 
//                                                                            []
// Выполнение запроса																			[]
//                                                                            []
//----------------------------------------------------------------------------[] 
// Проводим коррекцию базы данных в связи с уничтожением объекта
	DELETE_PROXY_OBJECT_OF (oc_meta);

// Уничтожаем объект
	oc_meta.Delete ();

//----------------------------------------------------------------------------[] 


	ERR_RETURN (ERR_OK);
}
//____________________________________________________________________________[]











/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[] END OF FILE                                                                []
[]                                                                            []
[]____________________________________________________________________________[]
*/