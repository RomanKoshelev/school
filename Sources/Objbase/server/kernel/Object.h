/*
________________________________________________________________________________
[]                                                                            []
[] This is a part of the PROJECT: 'ObjBase'												[]
[] Copyright (C) 1999 W:Brain                                                 []
[] All rights reserved.                                                       []
[] __________________________________________________________________________ []
[]                                                                            []
[] Name:            Object.h																	[]
[] Date:            14.04.99                                                  []
[] Author:          Roman V. Koshelev														[]
[] Description:     Базовый класс для всех контроллеров объектов базы данных	[]
[]____________________________________________________________________________[]
*/
#ifndef Object_h
#define Object_h

#include "SmartField.h"


class OC_Object;

#define RANGE_START	 NULL
#define RANGE_END		 NULL
//______________________________________________________________________________
//                                                                            []
//` Использование макроса STATIC_OC															[]
//  уменьшает оверхед на конструирование контроллеров.								[]
//                                                                            []
struct _STATIC_OC_CLOSER
{
	OC_Object * poc;
	_STATIC_OC_CLOSER (OC_Object* a_poc);
  ~_STATIC_OC_CLOSER ();
};
#define STATIC_OC(cl,obj)    static cl obj; _STATIC_OC_CLOSER _##obj##_closer(&obj)
//____________________________________________________________________________[]





template <class OC> class OC_Object_Temlate
{
// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (const OC& to) {return coPtr==to.coPtr;};
// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (const OC& to) {return coPtr!=to.coPtr;};
};

/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` OC_Object
[]                                                                            []
[]____________________________________________________________________________[]
*/
class OC_Object
{
// Это класс объектов-контроллеров.
// Использовать контроллеры (не "Мастер") можно двумя способами --
// прямым и индексным. В первом случае контроллер нужно
// проинициализировать с помощью уникального идентификатора.
// Во втором -- установить контроллер на объект, пользуясь 
// функциями работы с индексами -- Find, Next, Prev, ....
// Внимание: Класcы OC_xxx автоматически создаются компилятором базы данных.
   void About_class_OC_Object (){};

// Конструктор
	public:    OC_Object(){};

// Конструктор и открытие объекта
	public:    OC_Object(const guid& gi) {Open(gi);};

// Идентификатор класса объекта
   public:    identifier   classID;

// Внутренний идентификатор для доступа к данным через OBD
   protected: OBD_pointer  coPtr;

// Информация об установленном индексе
   protected: CIndexInfo   curIndexInfo;

// Очистить контроллер и уменьшить счётчик объекта-данных
   protected: void Release (OBD_pointer _coPtr=NULL);

// Закрыть контроллер = Release
   public: void Close ();

/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ОБЩИЕ МЕТОДЫ																					[]
[]                                                                            []
[]____________________________________________________________________________[]
*/

// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
   public: void DebugPrint(string& dbg) const;
// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
   public: void DebugPrint() const;
// Отладочная печать на экран в DOS-кодировке
	public: void DebugPrintDos() const;

// Проверка возможности использования контроллера
   public: bool IsValid () const;

// Проверка существования объекта данного класса с указанным идентификатором или guid.
   public: bool Exist (identifier objID) const;
// Проверка существования объекта данного класса с указанным идентификатором или guid.
   public: bool Exist (guid gi) const;

// Проверка возможности использования контроллера
   public: operator bool () const;

// Сохранение всей базы на диск (объекты и индексы)
// Для своего выполнения может потребовать времени ~266 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
	public: void SaveAllBase ();

// Сохранение всех изменённых объектов и индексов на диск. Операция полезна 
// для уплотнения памяти. Не требует специальных защитных мер -- можно вызывать в любой момент.
// Для своего выполнения может потребовать времени ~498 (266+232) секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
   public: void ReloadAllBase () const;

// Запись изменений в файловой системе.
// Для своего выполнения может потребовать времени ~7.7 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
   public: void FlushFileSystem () const;	


// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (identifier objID);

// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (identifier objID);

// Получить идентификатор контролируемого объекта
   public: operator identifier () const;

// Загрузка объекта по идентификатору или guid
   public: bool Open (identifier objID);
// Загрузка объекта по идентификатору или guid
   public: bool Open (const guid& gi);


// Принудительное сохранение объекта на диск
   public: void Save ();


// Создать новый объекта и добавить его в базу.
// Возвращает идентификатор нового объекта и устанавливает
// на него данный контроллер. 
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА!
   public: identifier New ();

// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete ();
// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete (identifier objID, bool bIgnoreWarning=false);


// Получить идентификатор контролируемого объекта.
   public: identifier GetObjectID () const;

// Получить уникальное значение контролируемого объекта.
   public: identifier GetObjectRN () const;

// Получить guid (CL, ID, RN) контролируемого объекта.
   public: void GetObjectGUID (guid& gi) const;

// Получить guid (CL, ID, RN) контролируемого объекта.
   public: guid GetObjectGUID () const {guid gi; GetObjectGUID(gi); return gi;};

// Получить идентификатор класса контролируемого объекта.
   public: identifier GetClassID () const;
// Получить имя класса контролируемого объекта.
   public: const char * GetClassName () const;




/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ ОБЪЕКТОВ														[]
[]                                                                            []
[]____________________________________________________________________________[]
*/

// Получить список идентификаторов всех объектов данного класса.
// Если уазан ключ, функция заполняет список идентификаторами 
// всех объектов, удовлетворяющих ключу. 
// Идентификаторы всегда будут отсортированы в соответствии с текущим индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: void GetClassIdList (identifier_arr& id_list, key_arr* pka=NULL);

// Получить список идентификаторов всех объектов данного класса,
// удовлетворяющих указанному диапазону по текущему индексу.
// Если первый ключ равен NULL -- объекты берутся с самого 
// начала индекса, если второй ключ равен NULL  -- объекты 
// берутся до самого конца индекса.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: void GetClassIdListInRange (identifier_arr& id_list, key_arr* pka1, key_arr* pka2);

// Удалить все объекты данного класса из базы.
// Для своего выполнения может потребовать времени ~41 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void DeleteClassObjects ();

// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
   public: void Delete (key_arr& ka);

// Принудительное сохранение текущего индекса на диск
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: void SaveCurIndex ();
// Получить идентификатор первого объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: identifier First() const;

// Получить идентификатор последнего объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: identifier Last() const;

// Значение ключа по текущему индексу меньше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator< (key_arr& ka);

// Значение ключа по текущему индексу меньше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator<=(key_arr& ka);

// Значение ключа по текущему индексу больше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator> (key_arr& ka);

// Значение ключа по текущему индексу больше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator>=(key_arr& ka);

// Сравнение значение ключа по текущему индексу с ключом-аргументом
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: int  Compare   (key_arr& ka);

// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
   public: bool operator== (key_arr& ka);

// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
   public: bool operator!= (key_arr& ka);

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Поиск по индексу
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// Поиск по простому ключу.
   public: bool Find (byte&		k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
   public: bool Find (bool&		k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
   public: bool Find (int&			k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
   public: bool Find (float&		k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
   public: bool Find (const char*k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
   public: bool Find (string&		k, bool bInexact=false) {key_arr ka; ka+=k; return Find (ka, bInexact);};
// Найти объект в текущем индексе по набору ключей 'ka' или одиночному ключу простого типа.
// При нестрогом поиске находится объект с ключём меньшим или равным ключу поиска:
//      key_arr ka; // Полный ключ = [Имя, Фамилия, Возраст]
//      ka += "Вася"; ka += "Пупкин"; ka += 28;
//      Men.Find (ka); // Находим Васю Пупкина 28-и лет и никого более.
//      Men.Find (ka, true); // Находим Васю Пупкина 28-и лет или Васю Пупкина 27-и лет 
//      // или Васю Аббакумова 92 лет или Абрамчика Цукермана 13 лет.
// Если набор ключей 'ka' неполный, игнорируются поля, не указанными в 'ka':
//      ka += "Вася"; ka += "Пупкин";
//      Men.Find (ka); // Находим первого попавшегося Васю Пупкина, причём
//      // его возраст будет минимальным среди всех имеющихся Васек Пупкиных.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool Find (key_arr&  ka, bool bInexact=false);

// Перейти на следующий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на следующий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на следующий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNext (key_arr* pka=NULL, bool bUnique=false);

// Перейти на предыдущий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на предыдущий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на предыдущий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrev (key_arr* pka=NULL, bool bUnique=false);

// Перейти по текущему индексу на следующий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNextSame (key_arr* pka=NULL, bool bUnique=false);

// Перейти по текущему индексу на предыдущий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrevSame (key_arr* pka=NULL, bool bUnique=false);

// Перейти на первый объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoFirst();

// Перейти на последний объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoLast ();

// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator++();
// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator++(int);

// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator--();
// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool operator--(int);


// Перейти по текущему индексу на следующий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoNextUnique ();

// Перейти по текущему индексу на предыдущий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: bool GoPrevUniqeu ();




// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Подсчёты по индексу
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum (key_arr& ka1, key_arr& ka2) const;

// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum (key_arr& ka) const;

// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
   public: size_t GetIndexUniqueNum () const;

// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum (key_arr& ka1, key_arr& ka2) const;

// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum (key_arr& ka) const;

// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetIndexTotalNum () const;

// Получить общее число объектов данного класса
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
   public: size_t GetTotalNum() const;
};
//____________________________________________________________________________[]



//______________________________________________________________________________
//                                                                            []
//` Отладочная печать всех объектов заданного класса                          []                                                
//                                                                            []
#define DEBUG_PRINT_CLASS(dbgclass)															\
{																										\
	OC_##dbgclass oc_obj;																		\
	for (oc_obj.GoFirst(); oc_obj.IsValid(); oc_obj++)									\
	{																									\
		oc_obj.DebugPrintDos();																	\
	}																									\
}
//____________________________________________________________________________[]





//______________________________________________________________________________
//                                                                            []
//` Получить идентификатор и контроллер класса ExtClass								[]
//  для указанного объекта класса BaseClass                                   []
//	 Если расширение не существует, оно создаётся										[]
//																										[]
#define GET_MOD_EXTENSION(BaseClass,BaseObjID,ExtClass,Ext)							\
identifier		Ext##ID=NA;																		\
{																										\
	DEBUG_STACK_NAME (GET_MOD_EXTENSION);													\
	if (!OC_Exist (OBJ_CLASS_ID_##BaseClass, BaseObjID))								\
	{																									\
		SERVER_DEBUG_ERROR_2 ("Указан несуществующий объект "							\
		"%d базового класса %s", BaseObjID, #BaseClass);								\
	}																									\
	else																								\
	{																									\
		OC_##BaseClass oc_base (BaseObjID);													\
		guid gi = oc_base.m_MOD_Extension_GUID;											\
		if (gi.id==NA)																				\
		{																								\
		/* OK. */																					\
			/* putchar ('.');	*/																	\
			OC_##ExtClass	oc_##Ext;															\
			oc_##Ext.New ();																		\
			oc_##Ext.GetObjectGUID		(gi);													\
			oc_base.m_MOD_Extension_GUID=gi;													\
			oc_base.GetObjectGUID	   (gi);													\
			oc_##Ext.m_MOD_Base_GUID   = gi;													\
																										\
			Ext##ID = oc_##Ext.GetObjectID();												\
		}																								\
		else /* Указан идентификатор объекта-расширения */								\
		{																								\
		/* Запрашиваемый класс-расширение не совпадает с хранящимся в базе */	\
			if (gi.cl != identifier (OBJ_CLASS_ID_##ExtClass))							\
			{																							\
				SERVER_DEBUG_ERROR_2 ("Запрашиваемый класс-расширение %s "			\
				"не совпадает с хранящимся в базе [%d]", 									\
				#ExtClass, identifier(gi.cl));												\
			}																							\
			else																						\
			{																							\
			/* OK. */																				\
				/* putchar ('+'); */																\
				Ext##ID = gi.id;																	\
			}																							\
		}																								\
	}																									\
}
//______________________________________________________________________________
//                                                                            []
//` Использовать указанный объект ExtObjID в качестве расширения BaseObjID		[]
//																										[]
#define SET_MOD_EXTENSION(BaseClass,BaseObjID,ExtClass,ExtObjID)					\
{																										\
	if (!OC_Exist (OBJ_CLASS_ID_##BaseClass, BaseObjID))								\
	{																									\
		SERVER_DEBUG_ERROR_2 ("Указан несуществующий объект "							\
		"%d базового класса %s", BaseObjID, #BaseClass);								\
	}																									\
	else																								\
	{																									\
		OC_##BaseClass oc_base (BaseObjID);													\
		guid gi = oc_base.m_MOD_Extension_GUID;											\
		if (gi.id !=NA || gi.cl !=NA)															\
		{																								\
		/* Объект уже имеет расширение */													\
			SERVER_DEBUG_ERROR_2 ("%s[%d] уже имеет расширение",						\
			#BaseClass, BaseObjID);																\
		}																								\
		/* Расширение ешё не существует -- создаём расширение */						\
		else																							\
		{																								\
			OC_##ExtClass oc_ext;																\
			ExtObjID = oc_ext.New ();															\
			oc_ext.GetObjectGUID			(gi);													\
			oc_base.m_MOD_Extension_GUID=gi;													\
			oc_base.GetObjectGUID	   (gi);													\
			oc_ext.m_MOD_Base_GUID      =gi;													\
		}																								\
	}																									\
}
//______________________________________________________________________________
//                                                                            []
//` Проверка на целостность модульных связей												[]
//																										[]
#define IF_NOT_CHECK_MOD_BASE(ExtClass,BaseClass,extGUID)							\
bool bRes_##ExtClass_##BaseClass=true;														\
{																										\
	bool bRes=true;																				\
	if (!OC_Exist (extGUID))																	\
	{																									\
		bRes=false;																					\
	}																									\
	else																								\
	{																									\
		OC_##ExtClass oc_ext(extGUID.id);													\
		guid baseGUID = oc_ext.m_MOD_Base_GUID;											\
		if (!OC_Exist (baseGUID))																\
		{																								\
			bRes=false;																				\
		}																								\
		else																							\
		{																								\
			OC_##BaseClass oc_base(baseGUID.id);											\
			if (oc_base.m_MOD_Extension_GUID != extGUID || 								\
				 oc_ext. m_MOD_Base_GUID		!= baseGUID  )								\
			{																							\
				bRes=false;																			\
			}																							\
		}																								\
	}																									\
	bRes_##ExtClass_##BaseClass = bRes;														\
}																										\
if(!bRes_##ExtClass_##BaseClass)
//____________________________________________________________________________[]





//______________________________________________________________________________
//                                                                            []
//` Устанавка значения расширяемого поля													[]
//                                                                            []
#define SET_EXT_FIELD(oc_xxx,field_name,value)											\
{																										\
	DEBUG_STACK_NAME (SET_EXT_FIELD);														\
	if (oc_xxx.m_FIELD_Extension_Name.Size() != oc_xxx.m_FIELD_Extension_Value.Size()) \
	{																									\
		SERVER_DEBUG_ERROR_2 ("Неисправимая ошибка: Разные размеры параллельных массивов FIELD_Extension_Name и FIELD_Extension_Value у объекта %s[%d]", oc_xxx.GetClassName(), oc_xxx.GetObjectID()); \
	}																									\
	else																								\
	{																									\
		int i = oc_xxx.m_FIELD_Extension_Name.Find(#field_name);						\
		if (i==-1)																					\
		{																								\
			oc_xxx.m_FIELD_Extension_Name.Add	(#field_name);						   \
			oc_xxx.m_FIELD_Extension_Value.Add	("");										\
			i = oc_xxx.m_FIELD_Extension_Name.Size()-1;									\
		}																								\
		oc_xxx.m_FIELD_Extension_Value[i] = string("").SetVariant(value);			\
	}																									\
}
//______________________________________________________________________________
//                                                                            []
//` Получение значения расширяемого поля													[]
//                                                                            []
#define GET_EXT_FIELD(oc_xxx,field_name,value)											\
{																										\
	DEBUG_STACK_NAME (GET_EXT_FIELD);														\
	if (oc_xxx.m_FIELD_Extension_Name.Size() != oc_xxx.m_FIELD_Extension_Value.Size()) \
	{																									\
		SERVER_DEBUG_ERROR_2 ("Неисправимая ошибка: Разные размеры параллельных массивов FIELD_Extension_Name и FIELD_Extension_Value у объекта %s[%d]", oc_xxx.GetClassName(), oc_xxx.GetObjectID()); \
	}																									\
	else																								\
	{																									\
		int i = oc_xxx.m_FIELD_Extension_Name.Find(#field_name);						\
		if (i!=-1)																					\
		{																								\
			string(oc_xxx.m_FIELD_Extension_Value[i]).GetVariant (value);			\
		}																								\
	}																									\
}
//____________________________________________________________________________[]



#endif
/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[] END OF FILE                                                                []
[]                                                                            []
[]____________________________________________________________________________[]
*/