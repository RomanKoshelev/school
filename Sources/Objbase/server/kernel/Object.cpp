/*
________________________________________________________________________________
[]                                                                            []
[] This is a part of the PROJECT: 'ObjBase'												[]
[] Copyright (C) 1999 W:Brain                                                 []
[] All rights reserved.                                                       []
[] __________________________________________________________________________ []
[]                                                                            []
[] Name:            Object.h																	[]
[] Date:            14.04.99                                                  []
[] Author:          Roman V. Koshelev														[]
[] Description:     Базовый класс для всех контроллеров объектов базы данных	[]
[]____________________________________________________________________________[]
*/
#ifndef ZOOB_UTILS

#define	USES_STATIC_FILE_ID_h
#define	USES_Ptr_h
#define	USES_string_h
#define	USES_AVTree_h
#define	USES_EventMonitor_h
#define	USES_File_h
#define	USES_key_arr_h
#define	USES_ObjDriver_h

#include "main.h"
#include "OBD.h"
#include "Object.h"

//______________________________________________________________________________
//                                                                            []
//` Используется для макроса STATIC_OC, который											[]
//  уменьшает оверхед на конструирование контроллеров.								[]
//                                                                            []
_STATIC_OC_CLOSER::_STATIC_OC_CLOSER (OC_Object* a_poc)
{
	poc = a_poc;
}
_STATIC_OC_CLOSER::~_STATIC_OC_CLOSER ()
{
	if (poc->IsValid ()) poc->Close ();
}
//____________________________________________________________________________[]




/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` OC_Object
[]                                                                            []
[]____________________________________________________________________________[]
*/
//----------------------------------------------------------------------------[] 
// Очистить контроллер и уменьшить счётчик объекта-данных
void OC_Object::Release (OBD_pointer _coPtr)
{
	DEBUG_STACK_NAME (Release);

   if(_coPtr!=NULL)
	{
      OBD_ReleaseObject (classID, _coPtr);
	}
   else if(coPtr!=NULL) 
	{
		OBD_ReleaseObject (classID, coPtr);
		coPtr = NULL;
   }
}
//----------------------------------------------------------------------------[] 
// Закрыть контроллер = Release
void OC_Object::Close ()
{
	DEBUG_STACK_NAME (Close);

	Release();
}
//----------------------------------------------------------------------------[] 



/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ОБЩИЕ МЕТОДЫ																					[]
[]                                                                            []
[]____________________________________________________________________________[]
*/
//----------------------------------------------------------------------------[] 
// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
void OC_Object::DebugPrint(string& dbg) const 
{
	DEBUG_STACK_NAME (DebugPrint);
	OBD_DebugPrint(classID, dbg, coPtr);
}
//----------------------------------------------------------------------------[] 
// Отладочная печать в строку.
// Если указан аргумент -- печатает в строку, иначе -- на экран.
void OC_Object::DebugPrint() const 
{
	DEBUG_STACK_NAME (DebugPrint);
	string dbg; 
	OBD_DebugPrint(classID, dbg, coPtr); 
	dbg.Print ();
}
//----------------------------------------------------------------------------[] 
// Отладочная печать на экран в DOS-кодировке
void OC_Object::DebugPrintDos() const 
{
	DEBUG_STACK_NAME (DebugPrintDos);
	string dbg; 
	OBD_DebugPrint(classID, dbg, coPtr); 
	dbg.win_2_dos();
	dbg.Print ();
}
//----------------------------------------------------------------------------[] 
// Проверка возможности использования контроллера
bool OC_Object::IsValid () const 
{
	DEBUG_STACK_NAME (IsValid);
	return OBD_IsObjectValid (classID, coPtr);
}
//----------------------------------------------------------------------------[] 
// Проверка существования объекта данного класса с указанным идентификатором
bool OC_Object::Exist (identifier objID) const 
{
	DEBUG_STACK_NAME (OC_Object_Exist);
	return OBD_Exist (classID, objID);
}
//----------------------------------------------------------------------------[] 
// Проверка существования объекта данного класса с указанным guid
bool OC_Object::Exist (guid gi) const 
{
	DEBUG_STACK_NAME (OC_Object_Exist);
	return OBD_Exist (gi.id, gi.id, gi.rn);
}
//----------------------------------------------------------------------------[] 
// Проверка возможности использования контроллера
OC_Object::operator bool () const 
{
	DEBUG_STACK_NAME (OC_Object_operator_bool);
	return IsValid ();
}
//----------------------------------------------------------------------------[] 
// Сохранение всей базы на диск (объекты и индексы)
// Для своего выполнения может потребовать времени ~266 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
void OC_Object::SaveAllBase ()  
{
	DEBUG_STACK_NAME (SaveAllBase);
	OBD_SaveAllData ();
}
//----------------------------------------------------------------------------[] 
// Сохранение всех изменённых объектов и индексов на диск. Операция полезна 
// для уплотнения памяти. Не требует специальных защитных мер -- можно вызывать в любой момент.
// Для своего выполнения может потребовать времени ~498 (266+232) секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
void OC_Object::ReloadAllBase () const 
{
	DEBUG_STACK_NAME (ReloadAllBase);
	OBD_ReloadAllBase();
}
//----------------------------------------------------------------------------[] 
// Запись изменений в файловой системе.
// Для своего выполнения может потребовать времени ~7.7 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
void OC_Object::FlushFileSystem () const 
{
	DEBUG_STACK_NAME (FlushFileSystem);
	theFileDriver.flush ();
}
//----------------------------------------------------------------------------[] 
// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
bool OC_Object::operator== (identifier objID)  
{
	DEBUG_STACK_NAME (OC_Object_operator_EQ);
	return objID == (coPtr? GetObjectID(): UNKNOWN);
}
//----------------------------------------------------------------------------[] 
// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
bool OC_Object::operator!= (identifier objID)  
{
	DEBUG_STACK_NAME (OC_Object_operator_NOT_EQ);
	return objID != (coPtr? GetObjectID(): UNKNOWN);
}
//----------------------------------------------------------------------------[] 
// Получить идентификатор контролируемого объекта
OC_Object::operator identifier () const        
{
	DEBUG_STACK_NAME (operator_identifier);
	return coPtr? GetObjectID(): UNKNOWN;
}
//----------------------------------------------------------------------------[] 
// Загрузка объекта по идентификатору
bool OC_Object::Open (identifier objID) 
{
	DEBUG_STACK_NAME (Open_identifier);

	if (coPtr!=NULL && (objID==GetObjectID())) 
		return false; 

	Release();

	if (objID==NA) 
	{
		SERVER_DEBUG_ERROR_1 ("OC_Object::Open (NA) -- попытка загрузить неизвестный объект класса '%s'", GetClassName ());
		return false;
	}
	coPtr=OBD_GetObject(classID,objID);

	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Загрузка объекта по guid
bool OC_Object::Open (const guid& gi) 
{
	DEBUG_STACK_NAME (Open_guid);
	if (!Open (gi.id))
	{
		return false;
	}
	if (gi.rn!=GetObjectRN())
	{
		SERVER_DEBUG_ERROR_4 ("%s[%d].rn=%d  != %d", GetClassName(), gi.id, GetObjectRN(), gi.rn);
		Release();
		return false;
	}
	if (gi.cl!=GetClassID())
	{
		SERVER_DEBUG_ERROR_4 ("%s[%d].cl=%d  != %d", GetClassName(), gi.id, GetClassID(), gi.cl);
		Release();
		return false;
	}
	return true;
}
//----------------------------------------------------------------------------[] 
// Принудительное сохранение объекта на диск
void OC_Object::Save () 
{
	DEBUG_STACK_NAME (Save);
	if (coPtr) OBD_SaveObject(classID,coPtr);
}
//----------------------------------------------------------------------------[] 
// Создать новый объекта и добавить его в базу.
// Возвращает идентификатор нового объекта и устанавливает
// на него данный контроллер. 
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА!
identifier OC_Object::New () 
{
	DEBUG_STACK_NAME (New);
	Release(); 
	coPtr=OBD_CreateObject(classID); 
	return GetObjectID();
}
//----------------------------------------------------------------------------[] 
// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
void OC_Object::Delete () 
{
	DEBUG_STACK_NAME (Delete);

	OBD_DeleteObject (classID, coPtr); 
	if (!IsValid()) 
	{
		Release ();
	}
}
// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
void OC_Object::Delete (identifier objID, bool bIgnoreWarning)
{
	DEBUG_STACK_NAME (Delete_objID);

	OBD_DeleteObject (classID, objID, bIgnoreWarning); 
	if (!IsValid()) 
	{
		Release ();
	}
}
//----------------------------------------------------------------------------[] 
// Получить идентификатор контролируемого объекта.
identifier OC_Object::GetObjectID () const 
{
	DEBUG_STACK_NAME (GetObjectID);
	return coPtr? OBD_GetObjectID(classID, coPtr): UNKNOWN;
}
//----------------------------------------------------------------------------[] 
// Получить уникальное значение контролируемого объекта.
identifier OC_Object::GetObjectRN () const 
{
	DEBUG_STACK_NAME (GetObjectRN);
	guid gi;
	GetObjectGUID (gi);
	return gi.rn;
}
//----------------------------------------------------------------------------[] 
// Получить guid (ID, RN) контролируемого объекта.
void OC_Object::GetObjectGUID (guid& gi)const 
{
	DEBUG_STACK_NAME (GetObjectGUID);
	gi.Init();
	if (coPtr)
	{
		OBD_GetObjectGUID (classID, coPtr, gi);
	}
}
//----------------------------------------------------------------------------[] 
// Получить идентификатор класса контролируемого объекта.
identifier OC_Object::GetClassID () const 
{
	DEBUG_STACK_NAME (GetClassID);
	return coPtr? OBD_GetClassID(classID, coPtr): classID;
} 
//----------------------------------------------------------------------------[] 
// Получить имя класса контролируемого объекта.
const char * OC_Object::GetClassName () const 
{
	DEBUG_STACK_NAME (GetClassName);
	identifier classID=GetClassID();
	if (classID<0 || classID>=(identifier)theObjDriver.m_FormatArr.Size())
	{
		static char SSS[1024];
		sprintf (SSS, "{{Несуществующий класс: classID = %d}}", classID);
		return SSS;
	}
	return className[classID];
}
//----------------------------------------------------------------------------[] 



/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[]` ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ ОБЪЕКТОВ														[]
[]                                                                            []
[]____________________________________________________________________________[]
*/
//----------------------------------------------------------------------------[] 
// Получить список идентификаторов всех объектов данного класса.
// Если уазан ключ, функция заполняет список идентификаторами 
// всех объектов, удовлетворяющих ключу. 
// Идентификаторы всегда будут отсортированы в соответствии с текущим индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
void OC_Object::GetClassIdList (identifier_arr& id_list, key_arr* pka)
{
	DEBUG_STACK_NAME (GetClassIdList);
	OBD_GetClassIdList (id_list, classID, pka, curIndexInfo);
}
//----------------------------------------------------------------------------[] 
// Получить список идентификаторов всех объектов данного класса,
// удовлетворяющих указанному диапазону по текущему индексу.
// Если первый ключ равен NULL -- объекты берутся с самого 
// начала индекса, если второй ключ равен NULL  -- объекты 
// берутся до самого конца индекса.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
void OC_Object::GetClassIdListInRange (identifier_arr& id_list, key_arr* pka1, key_arr* pka2)
{
	DEBUG_STACK_NAME (GetClassIdListInRange);
	OBD_GetClassIdListInRange (id_list, classID, pka1, pka2, curIndexInfo);
}
//----------------------------------------------------------------------------[] 
// Удалить все объекты данного класса из базы.
// Для своего выполнения может потребовать времени ~41 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
void OC_Object::DeleteClassObjects () 
{
	DEBUG_STACK_NAME (DeleteClassObjects);

	static key_arr ka;
	OBD_DeleteObjects (classID, ka, curIndexInfo); 
	if (!IsValid()) 
	{
		Release ();
	}
}
//----------------------------------------------------------------------------[] 
// 1. Удалить объект данного контраллера из базы.
// 2. Удалить объект с заданным идентификатором.
// 3. Удалить все объекты удовлетворяющие ключу * только для индексируемых классов
// * НЕПРИМЕНИМ К ОБЪЕКТАМ МАСТЕР-КЛАССА
void OC_Object::Delete (key_arr& ka)						
{ 
	DEBUG_STACK_NAME (Delete);

	OBD_DeleteObjects (classID, ka, curIndexInfo); 
	if (!IsValid()) 
	{
		Release ();
	}
}
//----------------------------------------------------------------------------[] 
// Принудительное сохранение текущего индекса на диск
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
void OC_Object::SaveCurIndex () 
{
	DEBUG_STACK_NAME (SaveCurIndex);

	OBD_SaveIndexToFile(classID,curIndexInfo);
}
//----------------------------------------------------------------------------[] 
// Получить идентификатор первого объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
identifier OC_Object::First() const 
{
	DEBUG_STACK_NAME (First);
	return OBD_FirstIDInIndex (classID, curIndexInfo);
}
//----------------------------------------------------------------------------[] 
// Получить идентификатор последнего объекта по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
identifier OC_Object::Last() const 
{
	DEBUG_STACK_NAME (Last);
	return OBD_LastIDInIndex (classID, curIndexInfo);
}
//----------------------------------------------------------------------------[] 
// Значение ключа по текущему индексу меньше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator< (key_arr& ka)  {return Compare (ka)< 0;}
//----------------------------------------------------------------------------[] 
// Значение ключа по текущему индексу меньше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator<=(key_arr& ka)  {return Compare (ka)<=0;}
//----------------------------------------------------------------------------[] 
// Значение ключа по текущему индексу больше ключа-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator> (key_arr& ka)  {return Compare (ka)> 0;}
//----------------------------------------------------------------------------[] 
// Значение ключа по текущему индексу больше или равно ключу-аргумента
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator>=(key_arr& ka)  {return Compare (ka)>=0;}
//----------------------------------------------------------------------------[] 
// Сравнение значение ключа по текущему индексу с ключом-аргументом
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
int  OC_Object::Compare   (key_arr& ka)  
{
	DEBUG_STACK_NAME (Compare);
	return coPtr? OBD_CompareToKeyVarArr (classID,curIndexInfo,coPtr,ka): -1;
}
//----------------------------------------------------------------------------[] 
// 1. Два контроллера указывают на один объект или оба не указывают ни на один объект.
// 2. Сравнение идентификатора контроллера с числом-идентификатором.
// 3. Значение ключа по текущему индексу равно ключу-аргументу * только для индексируемых классов
bool OC_Object::operator== (key_arr& ka)  {return Compare (ka)==0;}
//----------------------------------------------------------------------------[] 
// 1. Сравнение контроллеров -- два контроллера указывают на 
// разные объекты или один из них указывает на объект, а другой нет
// 2. Сравнение идентификатора контроллера с числом-идентификатором
// 3. Значение ключа по текущему индексу не равно ключу-аргументу * только для индексируемых классов
bool OC_Object::operator!= (key_arr& ka)  {return Compare (ka)!=0;}
//----------------------------------------------------------------------------[] 





// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Поиск по индексу
//
//----------------------------------------------------------------------------[] 
// Найти объект в текущем индексе по набору ключей 'keyarr'.
// При нестрогом поиске находится объект с ключём меньшим или равным ключу поиска:
//      key_arr ka; // Полный ключ = [Имя, Фамилия, Возраст]
//      ka += "Вася"; ka += "Пупкин"; ka += 28;
//      Men.Find (ka); // Находим Васю Пупкина 28-и лет и никого более.
//      Men.Find (ka, true); // Находим Васю Пупкина 28-и лет или Васю Пупкина 27-и лет 
//      // или Васю Аббакумова 92 лет или Абрамчика Цукермана 13 лет.
// Если набор ключей 'keyarr' неполный, игнорируются поля, не указанными в 'keyarr':
//      ka += "Вася"; ka += "Пупкин";
//      Men.Find (ka); // Находим первого попавшегося Васю Пупкина, причём
//      // его возраст будет минимальным среди всех имеющихся Васек Пупкиных.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::Find (key_arr& ka, bool bInexact) 
{
	DEBUG_STACK_NAME (Find);

	OBD_pointer _coPtr=coPtr; 
	coPtr = OBD_IndexFindObject (classID, curIndexInfo, ka, bInexact); 
	if(_coPtr)
	{
		Release(_coPtr);
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти на следующий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на следующий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на следующий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoNext (key_arr* pka, bool bUnique) 
{
	DEBUG_STACK_NAME (GoNext);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,pka,bUnique);   
	if(_coPtr)
	{
		Release (_coPtr); 
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти на предыдущий объект по текущему индексу.
// Если указан ключ (полный или неполный), перейти на предыдущий объект с удовлетворяющим ключом.
// Если указан аргумент bUnique=true, перейти на предыдущий уникальный по индексу объект.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoPrev (key_arr* pka, bool bUnique) 
{
	DEBUG_STACK_NAME (GoPrev);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,pka,bUnique);   
	if(_coPtr)
	{
		Release(_coPtr); 
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти по текущему индексу на следующий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoNextSame (key_arr* pka, bool bUnique) 
{
	DEBUG_STACK_NAME (GoNextSame);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,pka,bUnique,true);   
	if(_coPtr)
	{
		Release(_coPtr); 
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти по текущему индексу на предыдущий объект, имеющий тот же ключ.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoPrevSame (key_arr* pka, bool bUnique) 
{
	DEBUG_STACK_NAME (GoPrevSame);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,pka,bUnique,true);   
	if(_coPtr)
	{
		Release(_coPtr); 
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти на первый объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoFirst() 
{
	DEBUG_STACK_NAME (GoFirst);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexFirstObject (classID,curIndexInfo,coPtr);       
	if(_coPtr)
	{
		Release(_coPtr); 
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти на последний объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoLast () 
{
	DEBUG_STACK_NAME (GoLast);

	OBD_pointer _coPtr=coPtr; 
	coPtr=OBD_IndexLastObject  (classID,curIndexInfo,coPtr);       
	if(_coPtr)
	{
		Release(_coPtr);
	}
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator++() {return GoNext();}
//----------------------------------------------------------------------------[] 
// Перейти на следующий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator++(int) {return GoNext();}
//----------------------------------------------------------------------------[] 
// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator--() {return GoPrev();}
//----------------------------------------------------------------------------[] 
// Перейти на предыдущий объект по текущему индексу
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::operator--(int) {return GoPrev();}
//----------------------------------------------------------------------------[] 
// Перейти по текущему индексу на следующий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoNextUnique () 
{
	DEBUG_STACK_NAME (GoNextUnique);

	OBD_pointer _coPtr=coPtr; 
	static key_arr ka;
	coPtr=OBD_IndexNextObject  (classID,curIndexInfo,coPtr,&ka,true);   
	if(_coPtr) Release(_coPtr); 
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 
// Перейти по текущему индексу на предыдущий объект, имеющий другой ключ
// (перескочив через все одинаковые в смысле текущего индеква объекты).
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
bool OC_Object::GoPrevUniqeu () 
{
	DEBUG_STACK_NAME (GoPrevUniqeu);

	OBD_pointer _coPtr=coPtr; 
	static key_arr ka; 
	coPtr=OBD_IndexPrevObject  (classID,curIndexInfo,coPtr,&ka,true);   
	if(_coPtr) Release(_coPtr); 
	return coPtr!=NULL;
}
//----------------------------------------------------------------------------[] 






// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// Подсчёты по индексу
//
//RVK:>>> 
//----------------------------------------------------------------------------[] 
// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
size_t OC_Object::GetIndexUniqueNum (key_arr& ka1, key_arr& ka2) const 
{
	DEBUG_STACK_NAME (GetIndexUniqueNum);
	return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,true);
}
//----------------------------------------------------------------------------[] 
// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
size_t OC_Object::GetIndexUniqueNum (key_arr& ka) const 
{
	DEBUG_STACK_NAME (GetIndexUniqueNum);

	static key_arr ka2;
	return OBD_GetIndexNumForKey(classID,curIndexInfo,ka,ka2,true);
}
//----------------------------------------------------------------------------[] 
// Число уникальных объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- число уникальных в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
// Для своего выполнения может потребовать времени ~22.6 секунд @PII 233 для 4M объектов
// с единственным числовым полем и одним индексом, при подсчёте без ключа (по всему индексу).
size_t OC_Object::GetIndexUniqueNum () const 
{
	DEBUG_STACK_NAME (GetIndexUniqueNum);

	static key_arr ka1; 
	static key_arr ka2; 
	return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,true);
}
//----------------------------------------------------------------------------[] 
// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
size_t OC_Object::GetIndexTotalNum (key_arr& ka1, key_arr& ka2) const 
{
	DEBUG_STACK_NAME (GetIndexTotalNum);
	return OBD_GetIndexNumForKey(classID,curIndexInfo,ka1,ka2,false);
}
//----------------------------------------------------------------------------[] 
// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
size_t OC_Object::GetIndexTotalNum (key_arr& ka) const 
{
	DEBUG_STACK_NAME (GetIndexTotalNum);

	static key_arr ka2;
	return OBD_GetIndexNumForKey(classID,curIndexInfo,ka,ka2,false);
}
//----------------------------------------------------------------------------[] 
// Общее число объектов с заданным ключом в текущем индексе.
// Если ключ не задан -- общее число в текущем индексе (или 
// другими словами -- число объектов данного класса)
// Если указано два ключа -- число объектов, чьи ключи лежат
// в диапозоне ключей-аргументов.
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
size_t OC_Object::GetIndexTotalNum () const 
{
	DEBUG_STACK_NAME (GetIndexTotalNum);
	return OBD_IndexTotalNum (classID);
}
//----------------------------------------------------------------------------[] 
// Получить общее число объектов данного класса
// * ТОЛЬКО ДЛЯ ИНДЕКСИРУЕМЫХ КЛАССОВ
size_t OC_Object::GetTotalNum() const 
{
	DEBUG_STACK_NAME (GetTotalNum);
	return OBD_IndexTotalNum (classID);
}
//____________________________________________________________________________[]


#endif

/*______________________________________________________________________________
[]                                                                            []
[]                                                                            []
[] END OF FILE                                                                []
[]                                                                            []
[]____________________________________________________________________________[]
*/